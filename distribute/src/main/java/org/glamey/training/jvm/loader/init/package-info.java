/**
 * 类初始化、实例化是两个不同的东西
 * <p>
 * 类初始化只有一次，并且相关信息是共享的。
 * 类实例化可以多次。
 *
 * 类初始化
 * 1、new getstatic putstatic invokestatic，指令会导致类初始化，final修改的静态常量除外，因为是在编译器已经初始化完毕。
 * 2、反射：通过 reflect进行方法调用的时候，发现类未初始化，需要进行一次初始化。
 * 3、初始化一个类的时候，发现其父类未初始化，需要进行父类的初始化。
 * 4、JVM启动的时候，用户需要指定一个Main（包含main()这个类），虚拟机会先初始化这个主类。
 * 5、jdk1.7动态语言支持，如果一个java.lang.invoke.MethodHandler实例最后的解析结果是REF_getStatic REF_putstatic REF_invokestatic的方法句柄，
 * 如果这些方法句柄对应的类未初始化，则需要先触发初始化。
 *
 *
 * JVM定义：有切只有这5中场景才能进行类初始化，统称为对一个类的主动引用。
 * 其他场景下，所有引用类的方式都不会触发初始化，统称为被动引用。（子类直接调用父类的静态方法，不会触发子类的初始化，形如Son.Papa.PAPA_CONSTANTS）
 *
 *
 * ------------------------------------------------------------
 * 类实例化顺序（类静态变量、静态代码块、非静态代码块、构造方法代码块）
 *
 * 如果有继承关系，需要进行递归操作。
 *
 *        ^       Object                    ｜
 *        |       目标类的父类的父类的父类     ｜
 *        |      目标类的父类的父类            |
 *        |      目标类的父类                 |
 *        |      目标类
 *
 *  左边：不断向上查找，一直找到Object超类。
 *  右边：从超类开始向下实例化，一直到目标类。
 *
 *
 *
 * @author yang.zhou 2019.11.28.10
 */
package org.glamey.training.jvm.loader.init;